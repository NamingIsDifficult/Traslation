	当使用index API更新一个文档的时候，我们先读取原始的文档，然后修改，然后再重新将整个文档重新索引。最近一次的所有请求将会最终生效：也就是说最后一个被索引的文档将会被存储在Elasticsearch里面。如果有人在这个时间段里做了文档的变更，那么这些变更可能会丢失。
	大多数情况下，这都不是问题。我们的主要存储介质可能是关系型数据库，我们只是把数据复制到Elasticsearch里面来使之可以被搜索。两个人同时修改同一个文档的情况还是有比较小的概率发生的。或者只是有时会丢失一些数据对我们的业务来说并没有什么关系。
	但是有时丢失一个修改可能是很致命的。想象一下，我们正使用Elasticsearch来存储线上仓储系统仓库中工具的数量。每次我们卖出一个工具，就要把Elasticsearch中的仓储数量减一。
	假设有一天，管理层决定要促销，突然间我们每秒钟都要卖出好几个工具。假设有两个网络进程同时在运行，同时在处理一个工具的售卖，这时就会有并发的风险。其中一个进程对数量的变更就会因为另一个进程没有注意到获取到的数量已经过期而丢失。结果就是我们的仓库中工具的数量将会比数据显示的要少，消费者也可能因此而购买不到产品（线上显示库存还有）。
	并发数越大，或者获取数据与更新数据之间的间隔越长，这种现象就会越容易产生。
	悲观锁并发控制：
	这种策略被关系型数据库大规模的使用，这种方法假设冲突很有可能发生，所以按顺序将资源锁住来防止冲突。一个比较典型的示例就是在读取一行数据前先锁住它，保证只有拥有这个锁的线程可以在这行数据上做修改。
	乐观锁并发控制：
	Elasticsearch使用的是这种锁，这种方法假设冲突发生的可能性很小，所以不会试图锁住操作。但是，如果底层的数据在读取和写入之间被修改过了的话，更新就会失败。然后由应用本身来决定如何处理这个冲突。举例来说，它可以使用刷新后的数据重新试着更新，或者将此情况报告给使用者。
