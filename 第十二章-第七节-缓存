	前文简略的讨论了过滤器的计算方式。核心是一个位集合，表示了匹配过滤器的文档。Elasticsearch将这些位集合聚合缓存，以备后续使用。一旦被缓存，这些位集合就可以在相同的过滤器被被使用的时候重用，而不用重新计算。
	这些缓存的位集合很是智能，他们会按照增量更新。当索引新的文档的时候，只有新的文档需要被添加到已存的位集合中，而不是不断的重新计算整个位集合。过滤器和系统的其他部分一样，是实时的，所以你不需要担心缓存过期的问题。
	每个过滤器都是在第一时间被计算和缓存的，不管它是在哪里被使用。同样的，如果一个查询在多个地方使用了相同的过滤器，只有一个位集合会被计算然后被重用。
	以下面这个例子来说，查找条件是：
	1.在收件箱中并且没有被读过
	2.不再收件箱，但是被标记为重要
	"bool": {
	   "should": [
	      { "bool": {
	            "must": [
	               { "term": { "folder": "inbox" }}, 
	               { "term": { "read": false }}
	            ]
	      }},
	      { "bool": {
	            "must_not": {
	               "term": { "folder": "inbox" } 
	            },
	            "must": {
	               "term": { "important": true }
	            }
	      }}
	   ]
	}
	请求中的"term": { "folder": "inbox" } 出现了两次，它们会使用相同的位集合。即使它们所在的上下文不一样，这两个子句本身是没有区别的。这意味着位集合只会被计算一次，然后相同的子句都回重用这个位集合。当这个查询第二次被执行的时候，相同的过滤器已经被缓存了，所以它们都会使用缓存过的位集合。
	这和结构化查询语句关系密切。将过滤器放置在任意地方，或者在同一个查询的多个位置使用相同的过滤器。这对于开发者来说不是很放iban，但是对性能有相当的好处。
	大部分的叶子过滤器，即直接对字段值做操作的过滤器，比如短语过滤器，都会被缓存。而组合的过滤器，比如布尔过滤器则不会被缓存。
	叶子过滤器必须要询问未与硬盘中的反向索引，所以缓存他们还是很有意义的。组合过滤器的实质是在内部执行快速的逻辑位运算把内部子句的位集合进行整合，所以重新计算也依旧很高效。
	以下过滤器并未被缓存，因为没甚意义：
	1.脚本(Script)过滤器
	2.经纬度(Geo)过滤器    这个过滤器通常是用于过滤指定用户的经纬度的，由于用户的经纬度不太可能不变，所以缓存没啥意义
	3.日期范围   使用now方法(比如"now-1h")的日期范围是变动的，所以默认不会缓存。但是，当使用now取整的时候，默认是缓存的。
	有事，默认的缓存策略是不合适的，比如你可能会有一个复杂的布尔表达式在哦天哪跟一个查询中多次重用，或者有一个日期字段上的过滤器需要不被重用，这时，可以使用_cache标志来覆盖默认的缓存策略：
	{
	    "range" : {
	        "timestamp" : {
	            "gt" : "2014-01-02 16:15:14" 
	        },
	        "_cache": false 
	    }
	}
	
