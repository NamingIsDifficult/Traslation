	被分析过的字符串字段也是一种多值字段，在这之上做的排序大部分情况下和你想象的不一样。如果对fine old art字串做分析，它会被分解为3个短语。我们的排序需求可能是要按照第一个短语的字母顺序进行排序，然后是第二个，等等，但是在处理排序的时候，Elasticsearch并没有得到这样的信息。
	你可以使用min或者max排序模式（默认是min），结果就是按照art或者old来排序，而你想要的并不是按照它们中的任意一个来排序。
	为了能在一个字符串字段上做排序，这个字段必须只有一个短语：即整个未被分析过的字串。当然，在满足这个情况下，我们还是想要将这个字段进行分析，这样才能做全文搜索。
	最朴素的方法是将同一个字串按两种方法索引，这样会导致在文档中加入两个相互分离的字段，一个是被分析过的，用于搜索，另一个则未被分析，用于排序。
	但是在_source字段中对同一个字串做两次排序浪费空间，我们实际想要的是在一个字段中传递参数，但是索引时会按照两种方式索引。所有的核心字段类型(strings,numbers,booleans,dates)都接受一个fields参数来传递以下映射关系：
	"tweet": {
	    "type":     "string",
	    "analyzer": "english",
	    "fields": {
	        "raw": { //tweet.raw这个子字段是未被分析的
	            "type":  "string",
	            "index": "not_analyzed"
	        }
	    }
	}
	现在，一旦重新索引好数据后，就可以使用tweet字段来搜索，按照tweet.raw字段来排序了。
	另外，对一个分析过的全文本字段排序的话将会消耗大量的内存。
