	对于随机打分的逻辑以及它的使用场景你可能还有疑问，之前的例子提供了一个很好的使用场景，该例子的所有结果最终产生的得分可能是1，2，3，4，5，可能只有很少的房子得分能到5，但是大概有很多房子的得分会是2或者3.作为网站的所有者，你希望对你的广告主的曝光率尽量提升,而当前的查询产生的结果中，同样分数的文档的顺序是不变的。所以引入一些随机性在其中可以使得分数相同的文档获得大致相同的曝光率。
	我们希望每个用户看到的排序是不同的，但是我们还希望单个用户看到的排序又是固定的，这就是所谓的一致性随机。
	random_score方法的输出介于0-1之间，当提供相同的种子值得时候会产生一致性随机结果，种子值可以选用用户的会话id:
	GET /_search
	{
	  "query": {
	    "function_score": {
	      "filter": {
	        "term": { "city": "Barcelona" }
	      },
	      "functions": [
	        {
	          "filter": { "term": { "features": "wifi" }},
	          "weight": 1
	        },
	        {
	          "filter": { "term": { "features": "garden" }},
	          "weight": 1
	        },
	        {
	          "filter": { "term": { "features": "pool" }},
	          "weight": 2
	        },
	        {
	          "random_score": { //该子句将会被应用到所有匹配的文档
	            "seed":  "the users session id" 
	          }
	        }
	      ],
	      "score_mode": "sum",
	    }
	  }
	}
	当然，如果索引了新的文档，并且还匹配了查询的话，结果集的顺序还是会变化的，这和是否使用了一致性随机没有关系
