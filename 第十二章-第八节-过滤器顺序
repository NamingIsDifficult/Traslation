	在布尔子句中的过滤器的顺序对于性能有着重要的影响。针对性越强的过滤器应该相对的放在更前面的地方来及早的过滤掉不匹配的文档，因为过滤器的执行顺序与子句中的排列顺序相同。
	缓存后的过滤器很快，所以它们应该比还未缓存的过滤器放在靠前的位置。想象一下有一个包含了一个月的日志事件的索引，但是我们最感兴趣的仅仅是上一个小时的数据：
	GET /logs/2014-01/_search
	{
	    "query" : {
	        "filtered" : {
	            "filter" : {
	                "range" : {
	                    "timestamp" : {
	                        "gt" : "now-1h"
	                    }
	                }
	            }
	        }
	    }
	}
	这个过滤器是不会被缓存的，这意味着我们每次运行的时候都需要检查整个月的日志事件。我们可以通过结合一个可以被缓存的过滤器来大大提高性能。比如添加一个固定日期作为过滤器：
	"bool": {
	    "must": [
	        { "range" : {
	            "timestamp" : {
	                "gt" : "now-1h/d" //这个过滤器会被缓存
	            }
	        }},
	        { "range" : {
	            "timestamp" : {
	                "gt" : "now-1h" //这个过滤器不会被缓存
	            }
	        }}
	    ]
	}
	now-1h/d子句被取整为上一个午夜的时间，所以它排除了今天之前创建的文档，位集合结果会被缓存，因为now被固定了，所以当midnight-last-night的值变化的时候，每天只要计算一次。now-1h子句并没有被缓存，因为now是最近的1毫秒，总是变化的。不过，由于有了第一个过滤器，第二个过滤器只需要检查自午夜至今产生的文档了。
	
