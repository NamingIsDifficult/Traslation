	在子句前置一节中，我们解释了如何在查询阶断使用boost参数来给查询子句增加权重，比如：
	GET /_search
	{
	  "query": {
	    "bool": {
	      "should": [
	        {
	          "match": {
	            "title": {
	              "query": "quick brown fox",
	              "boost": 2 //该子句比其他默认子句的权重高两倍
	            }
	          }
	        },
	        {
	          "match": { //默认boost值为1
	            "content": "quick brown fox"
	          }
	        }
	      ]
	    }
	  }
	}
	查询阶断的权重提升是调整关联分的主要手段，任何类型的查询都接收boost参数。将权重提升设置为2并不意味着最终的得分会提高两倍；实际的权重提升数值还要通过规范化和一些内部优化调整后才被应用。但是这也暗示了一个值为2的子句要比值为1的子句高两倍。
	实际应用中，并没有一个简单的标准来确定某个子句使用多大的权重是正确的。这是一个边试边看的过程。需要注意的是boost只是参与到关联打分的诸多因素中的一个。比如，在这个例子中，title字段可能已经有了一个潜在的高于content字段的权重，这个潜在的提升有可能是字段长度规范化时产生的，因为标题通常要比文本短得多。所以不要凭直觉盲目的提升字段的权重。在应用这个参数的时候要检查结果集，不断的尝试来获取最佳的值。
	当跨多个索引查询的时候，可以使用indices_boost参数来提升整个索引的权重，举例如下：
	GET /docs_2014_*/_search 
	{
	  "indices_boost": { 
	    "docs_2014_10": 3,
	    "docs_2014_09": 2
	  },
	  "query": {
	    "match": {
	      "text": "quick brown fox"
	    }
	  }
	}
	提升的数值在t.getBoost()元素中展示，权重提升并不会在查询DSL阶断被使用，任意提升值都会被整合并且传递到更底层的单独的短语。t.getBoost()方法返回任意被应用于该字段或者任意处理链中更高层的查询的boost值。实际上，阅读explaination API的输出时还要比这里所描述的更为复杂，这里看不到boost值或者t.getBoost（），权重提升被揉杂在queryNorm里面并且应用与特定的短语。尽管我们说queryNorm对每个短语来说都是一样的，但是被提升过的短语显然要比未被提升的短语的queryNorm高。
