	这里使用英国的邮编来展示如何对结构化数据进行部分匹配。邮编的结构定义的很严格，比如区号W1V 3DG可以被拆分为：
	W1V:这部分确定了邮政区域和目的地：
		W表示区域，可能有1-2位字母
		1V表示目的地可能有1-2个数字，后面可能会跟随一个字母
	3DG:这部分确定了街道或建筑:
		3表示分区，1个数字
		DG表示单元,2个字母
	假设我们把邮编按照精确值not_analyzed方式索引：
	PUT /my_index
	{
	    "mappings": {
	        "address": {
	            "properties": {
	                "postcode": {
	                    "type":  "string",
	                    "index": "not_analyzed"
	                }
	            }
	        }
	    }
	}
	然后在索引部分文档：
	PUT /my_index/address/1
	{ "postcode": "W1V 3DG" }
	
	PUT /my_index/address/2
	{ "postcode": "W2F 8HW" }
	
	PUT /my_index/address/3
	{ "postcode": "W1F 7HW" }
	
	PUT /my_index/address/4
	{ "postcode": "WC1N 1LZ" }
	
	PUT /my_index/address/5
	{ "postcode": "SW5 0BE" }
	要找出所有按照W1开头的邮编的话，可以使用简单的prefix查询：
	GET /my_index/address/_search
	{
	    "query": {
	        "prefix": {
	            "postcode": "W1"
	        }
	    }
	}
	前缀查询是一个底层查询，它工作在短语层面。在查询之前它不会分析查询字串，它假设你传入的就是想要查找的文档的前缀。默认情况下，前缀查询不做关联打分。它只是找到所有匹配的文档并且打1分，所以它的行为更像是一个过滤器而不是一个查询。前缀查询和前缀过滤器唯一的区别是能不能被缓存。
	前面我们提到的问题是，你只能找到反向索引中出现过的短语，但是我们并没有对这些邮编做任何的特殊处理；每个邮编只是按照精确值索引至相应的字段，所以前缀查询是怎么工作的呢？
	反向索引是由独特的短语组成的列表，对于每个短语，列出包含这个短语的文档ID，示例文档的反向索引如下：
	Term:          Doc IDs:
	-------------------------
	"SW5 0BE"    |  5
	"W1F 7HW"    |  3
	"W1V 3DG"    |  1
	"W2F 8HW"    |  2
	"WC1N 1LZ"   |  4
	-------------------------
	为了在高速运行中支持前缀匹配，查询会做这几步：
	1.遍历短语列表找出第一个以W1开头的短语
	2.收集关联的文档id
	3.移动到下一个短语
	4.如果还是匹配，跳至步骤2，否则结束
	对于这个简单的例子来说，这个工作流程没有问题，但假设反向索引中包含了百万个W1开头的邮编，那么前缀查询将会按照顺序访问这些短语并且计算结果，而且前缀越短，需要访问的短语就可能越多。
	前缀查询对于特别的前缀匹配很有用，但是需要谨慎使用。他们可以在数量较少的短语上使用，但是当负载提高的时候，表现就会越来越差。注意使用长一些的前缀来减少影响，这会减少要计算的短语数量。
