	第一个挑战就是要解决如何使文本可搜索的问题.传统数据库在每个字段中存储一个值，这对于全文本搜索来说是完全不够的。文本字段中的每一个单词都要是可搜索的。这意味着数据库要能对一个字段中的值做多个索引。
	支持单个字段多个值得最佳数据结构就是反向索引，反向索引是一个包含所有独立的值或短语的已排序的列表。这些值来自于索引的文档。对于每个值来说，也有一个包含它的文档的列表。
	Term  | Doc 1 | Doc 2 | Doc 3 | ...
	------------------------------------
	brown |   X   |       |  X    | ...
	fox   |   X   |   X   |  X    | ...
	quick |   X   |   X   |       | ...
	the   |   X   |       |  X    | ...
	我们所讨论的反向索引指的是对Elasticssearch定义的文档做索引，因为历史上所说的反向索引指的是对整个非结构化的文档进行索引。在Elasticsearch中的文档是结构化的字段和值。设计上，每一个被索引的JSON文档的字段都有自己的反向索引。
	反向索引相对于包含特定短语文档列表包含了多得多的信息。它存储了包含各个短语的文档那个的数量、某个文档中特定短语出现的次数、每个文档的长度，所有文档的平均长度，等等。这些统计数值帮助Elasticsearch决定哪些短语要相较其它的更为重要，哪个文档相较其它文档更为重要。
	需要注意的是，反向索引需要知道集合中所有的文档来支持搜索和分析的功能。
	在早期的全文搜索中，会为所有的文档创建一个巨大的反向索引并且将之写入到磁盘中。新索引一旦准备好就会替换掉旧的索引，并且最新的变更也会变得可以搜索。
	写入到磁盘中的反向索引是不可变的，这是因为这些原因：
	1.无需加锁。
	2.一旦文档被读入文件系统的内核缓存中，就可以一直保留。只要文件系统的缓存空间足够，就可以通过内存来获取而不用从磁盘获取。
	3.所有关联的其它缓存在索引生存的期间都是可用的。
	4.写入一个大的反向索引意味着数据可以被压缩，可以减少磁盘I/O和缓存所需的内存大小。
	当然，这样做也有弊端，显而易见的是它不可变。如果要想使得新的文档可以被搜索的话，必须要重新索引所有数据。这就大大的限制了一个索引能包含的数据的大小，以及索引被更新的次数
