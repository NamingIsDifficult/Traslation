	Elasticsearch中类型表示一组类似的文档。一个类型由一个名词（比如user或者blogpost之类）和一个一个映射表组成。映射表就像是一个数据库的目录，描述了这个类型的文档都有哪些字段或者属性，每个字段的数据类型，比如string,integer,date等，以及这些字段在Lucene中是如何索引和存储的。
	前文曾经提及类型与传统关系型数据库中的表类似。这在一开始用于理解类型的时候是一个不错的例子，不过更加深入的解释类型是什么已经在Lucene之上是如何实现类型是很有必要的。
	Lucene中的一个文档包含一组简单的键值对。一个字段至少要有一个值，不过任意字段都可以有多个值。同样的道理，一个字符串可能会在分析过程之后被转换成多个值。Lucene并不区分数据的类型，所有的值都被当成是不透明的字节。
	当在Lucene中对一个文档进行索引的时候，值都被添加到了关联字段的反向索引中。当然，原始数据也会被存储，这样接下来就可以获取它们了。
	Elasticsearch类型是在这个基础之上建立的。一个索引可能会有多个类型，每一个都有自己的映射表，而这些类型的文档都有可能存储在相同的索引中。
	Lucene中是没有文档类型这个概念的，每个文档的类型名称都在文档的原数据字段_type中存储。当搜索一个特定的类型的文档的时候，Elasticsearch只是在_type字段上添加一个过滤器来限制文档的类型的。
	Lucene中也没有映射表这个概念，映射表是Elasticsearch用于将复杂的JSON文档映射到Lucene期望获取的扁平化的文档格式。
	举例来说，user类型中的name字段在映射表中可能会被声明是一个string字段，而且在索引至name索引中之前应该使用whitespace分析器来处理输入。
	"name": {
	    "type":     "string",
	    "analyzer": "whitespace"
	}
	实际上在一个索引中添加不同的类型也引入了预计之外的复杂度。
	想象一下，blog_en索引中有两个类型来分别处理英文和西班牙文的博客。它们都有title字段，但是一个使用english分析器，一个使用spanish分析器。
	当出现以下查询的时候，就有问题了：
	GET /_search
	{
	    "query": {
	        "match": {
	            "title": "The quick brown fox"
	        }
	    }
	}
	这个查询涉及到了两个类型，而且查询的都是title字段，查询字串要用哪一种分析器来分析呢？它会使用第一个被找到的文档的title字段使用的分析器来做分析，这样话，对部分文档来说是正确的，其它的则是错误的。
	我们可以通过将字段名称修改为不同的名称来避免这个问题，或者在查询中明确标识出类型名称并且分别查询：
	GET /_search
	{
	    "query": {
	        "multi_match": { //这个查询可以对多个字段运行查询命令
	            "query":    "The quick brown fox",
	            "fields": [ "blog_en.title", "blog_es.title" ]
	        }
	    }
	}
	新的查询将会对blog_en.title使用english分析器，而blog_es.title使用spanish分析器，并且将结果整合在一起，使用全局的关联打分来排序。
	这个解决方案用来解决多个字段有相同数据类型的问题，但是如果两个类型中有同一个文档的话：
	Type: user
	 { "login": "john_smith" }
	Type: event
	 { "login": "2014-06-01" }
	 Lucene对于两个字段中的值的类型并不做区分，它会照常对两个字段进行索引。
	 但是，如果我们现在要尝试去对event.login字段进行排序的话，Elasticsearch需要将值加载进内存，在字段数据一节中我们说过，它把所有的文档都加载进内存，而且不区分类型。
	 它会尝试按照第一个遇到的字段的类型去加载接下来的文档，这可能会导致不合理的结果或者报错。
	 为了保证不出现这些问题，推荐的做法是保证有相同名称的字段在同一个索引中的类型映射是一样的。
