	wildcard查询是一个底层基于短语的查询，它的本质和prefix类似，但它允许你指定一个格式而非前缀。它使用基本的通配符：?匹配任何字符，*匹配0-多个字符。
	以下查询将会匹配包含 W1F 7HW 和 W2F 8HW的文档：
	GET /my_index/address/_search
	{
	    "query": {
	        "wildcard": {
	            "postcode": "W?F*HW" 
	        }
	    }
	}
	想象一下，如果需要匹配任意区域为W的邮编，那么一个前缀匹配也会匹配由WC开头的邮编，它们就都会有相同的问题，我们只需要匹配W开头并且紧随其后的是数字，这是regexp查询允许你用更复杂的格式来匹配：
	GET /my_index/address/_search
	{
	    "query": {
	        "regexp": {
	            "postcode": "W[0-9].+" 
	        }
	    }
	}
	通配符和正则查询与前缀查询的匹配方式完全一样，他们都需要扫描反向索引中的短语列表来匹配，并且逐个短语收集文档id.他们与前缀查询的不同之处仅仅在于支持更复杂的匹配格式。所以使用他们需要注意的地方是一样的，在短语很多的字段上运行它们可能会使得花销过大，最好避免开头使用通配符。比如*foo或者.*foo。
	鉴于可以在索引阶段把数据准备成对前缀查询更为有效率的格式，通配符和正则查询则只能在查询阶段优化。这些查询都有使用的地方，但是要谨慎的去使用。
	前缀、通配符、正则查询是在短语上进行操作的。如果对一个分析过的字段使用这些查询的话，他们会检验字段中的所有的短语，而不是整个字段。比如说一个包含“Quick brown fox” 的title字段，将会产生3个短语quick, brown, and fox，这个查询将会匹配：
	{ "regexp": { "title": "br.*" }}
	但是这两个却不会：
	{ "regexp": { "title": "Qu.*" }} 
	{ "regexp": { "title": "quick br*" }} 
