	在对文本做了反向索引处理后，需要做的是保持不可变带来的好处的同时解决更新反向索引的问题。答案是使用多个索引。
	通过添加补充的索引来反映最近的变更，而不是重写整个反向索引。每个反向索引都可以按顺序被查询，从最旧的开始，最后将所有的结果整合在一起。
	Elasticsearch所基于的Lucene的java库引入了分段查询的概念。一个分段指的是一个反向索引本身，Lucene中的index表示分段的一个集合加上一个提交点，提交点指的是一个罗列了所有已知分段的文件。在写入一个硬盘中的分段内之前，新文档首先会被添加到一个内存中的索引缓冲区中。
	一个Lucene的index（索引）在Elasticsearch中被叫做shard（分片）,而Elasticsearch中的index则指的是一组分片。当Elasticsearch在一个索引中执行查询的时候，它将查询语句发送给索引中的每一个分片，即Lucene中的index，然后再一个全局结果集中去除每个分片结果中的重复部分。
	一个分段查询的工作情况如下：
	1.新的文档被收集到一个内存中的索引缓冲区
	2.以下情况发生时，缓冲区将会被提交：
		2.1.一个新的分段，即补充的反向索引写入到硬盘中
		2.2.一个新的提交点被写入硬盘，其中包含了新分段的名称
		2.3.硬盘是fsync'ed，即所有在文件系统缓存中等待的文件都被冲刷到硬盘中，保证它们都已被确实的写入。
	3.新的分段被打开，其中的文档对搜索可见
	4.内存中的缓冲区被清空，并且准备好接收新文件
	当查询发出的时候，所有已知的分段将会按顺序被查询。短语统计数据在所有分段中聚合出来，以此保证每个短语和文档的关联程度计算正确。这种情况下，新文档被添加到索引中的代价就降低了许多。
	分段是不可变的，所以旧分段中的文档时不能被移除的，旧分段中的文档也不能被更新到新版本。所以每个提交点都包含一个.del文件，其中列出了哪个分段中的哪些文件被删除了。
	当一个文档是被删除状态时，它只是在.del文件中被标记为已删除。一个被标记的文档依旧可能会被查询匹配到，但是它会在最终结果返回之前被移除掉。
	文档更新的工作方式和这个类似：当一个文档被更新的时候，旧版本的文档被标记为已删除，然后新版本的文档将被索引到新的分段中。有可能两个版本的文档都会匹配查询，但是旧的被删除的版本将会在最终结果返回之前被移除。
	在分段合并一节将会介绍已删除的文档时如何从文件系统中被净化的。
	
