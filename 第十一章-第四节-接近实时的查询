	通过使用分段查询的手段，可以把索引一个文档到文档可以被搜索之间的延迟奇迹般的降低到分钟级，但是还是不够快。
	这里的瓶颈是硬盘。将一个分段提交到硬盘中需要使用fsync来保证分段确实被写入到硬盘，并且即使断电也不会丢失数据。但是fsync非常的耗费资源，它不能每次有文档被索引的时候就被执行。
	这里需要的是一个轻量级的方式来使得新文档可以被搜索，这意味着要在过程中移除fsync。
	在Elasticsearch和硬盘中的是文件系统的缓存。之前的过程中，在内存的索引缓冲区中的文档会被写入到一个新的分段。但是新的分段首先会被写入到文件系统缓存中，这样的消耗更小，更晚一些才会将数据冲刷到硬盘中，这是一个消耗很大的操作。但是一旦文档被缓存了，它就可以被打开和读取，与其他的文件一样。
	Lucene允许分段在被写入的同时也被打开，这使得文档保持对搜索可见而不用执行完整的提交。这比执行一次提交要轻量的多，可以在不损害性能的情况下频繁执行。
	在Elasticsearch中，执行写入的同时打开新分段的轻量级进程叫做refesh。默认情况下，每个分片美妙照哦给你都会自动刷新一次。这就是我们说Elasticsearch近似实时的原因：文档变更对于搜索来说并不是立刻可见，但延迟也在1秒以内。
	这对于新的使用者来说可能会比较难以理解：他们索引了一个文档，然后尝试着去搜索它，然而却没有结果。这种情况下需要手动的去执行一次刷新，可以使用refresh API:
	POST /_refresh //刷新所有索引
	POST /blogs/_refresh  //刷新blogs索引
	虽然刷新相比提交来说已经轻量的多了，但是依旧对性能是有影响的。一次手动的刷新在测试阶段或许挺有用的，然而如果每次索引文档的时候都做手动刷新的话将会对性能产生影响。所以你的应用需要认识到Elasticsearch近似实时的本质，并且相应的去适应它。
	并不是所有的应用场景都需要每秒刷新一下。可能你需要使用Elasticsearch来索引百万级的日志文件,这时，索引速度的优化要比实时搜索来的更加重要。可以通过设置索引基本设置中的刷新频率来提高索引性能：
	PUT /my_logs
	{
	  "settings": {
	    "refresh_interval": "30s" 
	  }
	}
	已存的索引中的refresh_interval可以被动态更新。你可以在建立一个大型的新索引的时候关闭自动刷新，然后在开始使用的时候再设置回去：
	PUT /my_logs/_settings //关闭自动刷新
	{ "refresh_interval": -1 } 
	
	PUT /my_logs/_settings
	{ "refresh_interval": "1s" } 
	refresh_interval的有效值在1秒钟到2分钟。
